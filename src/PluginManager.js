/* 
* @Author: mike
* @Date:   2015-05-18 17:05:09
* @Last Modified 2016-01-20
* @Last Modified time: 2016-01-20 20:31:35
*/

'use strict';

import findup from 'findup-sync'
import multimatch from 'multimatch'
import fs from 'fs'
import path from 'path'
import _ from 'underscore'

/**
 * The PluginManager handles all of the module loading.  Load order is as follows:
 *
 * 1. Packages in node_modules that match the passed `namespace` config option, and packages in the `@nxus` namespace.
 * 2. Folders in the <appDir>/modules directory.
 * 3. Filepaths passed in the `modules` config option
 */
class PluginManager {

  constructor(options) {
    options = options || {}

    var packages = []

    this.loadPackages(options, packages)
    this.loadCustomPlugins(options, packages)
    this.loadPassedPlugins(options, packages)

    return packages
  }

  /**
   * Helper method to ensure a passed variable is an array. Wraps the value in an array if it isn't already.
   * @param  {anything} el the item to ensure is an array
   * @return {Array}    either a new empty array, or el as is if its an array, or el wrapped in an array.
   */
  arrayify(el) {
    if(!el) return []
    return Array.isArray(el) ? el : [el]
  }

  /**
   * Loads the package.json file for the specified packages.
   * @param  {string} path the root package folder path
   * @return {object}      the parsed json object in package.json
   */
  getPluginPackageJson(path) {
    if(fs.existsSync(path + "/package.json"))
      return JSON.parse(fs.readFileSync(path + "/package.json", "utf8"))
  }

  /**
   * Loads the dependencies for a particular package, as defined by the 'dependencies' object in the package.json file.
   * @param  {object} pkg the package object generated by accumulatePackage()
   * @return {array}     an array of the package's dependencies, as filepaths or node_module names
   */
  getDeps(pkg) {
    var deps = (pkg._packageJson && pkg._packageJson.dependencies) || {}
    return _.filter(Object.keys(deps), function (packageName) {
        return packageName.indexOf("@nxus/") === 0
      }) || []
  }
  
  /**
   * Creates the internal representation of a package
   * @param  {array} packages  the list of active packages being loaded by Nxus
   * @param  {string} directory the directory of the new package to load
   * @return {object}           the package, as returned by `require`
   */
  accumulatePackage(packages, directory) {
    var pkg = require(fs.realpathSync(directory))
    pkg._packageJson = this.getPluginPackageJson(directory)
    pkg._pluginInfo = {}
    pkg._pluginInfo.name = pkg._packageJson.name
    packages.push(pkg)
    return pkg
  }
  
  /**
   * Loads a package
   * @param  {string} name      The name of the package
   * @param  {string} directory A path to the package
   * @param  {array} packages  An array of the currently loaded packages
   */
  loadPackage(name, directory, packages) {
    if (process.env.debug) console.log('loading package ' + name)
    var pkg
    if (fs.existsSync(directory)) {
      pkg = this.accumulatePackage(packages, directory)
    }
    if(!pkg) return
    var getPackages = (packages, targets, directory) => {
      targets.forEach((t) => {
        var innerDir = path.join(directory, 'node_modules') + '/' + t
        var innerPkg = this.accumulatePackage(packages, innerDir)
        if(!innerPkg) return
        // recurse through all child packages
        getPackages(
          packages,
          this.getDeps(innerPkg),
          innerDir
        )
      })
    }
    getPackages(packages, this.getDeps(pkg), directory)
  }

  /**
   * Loads all Nxus pacakges for an application
   * @param  {object} options  options to use to load the packages
   * @param  {packages} packages the array of packages currently loaded by Nxus
   */
  loadPackages(options, packages) {
    var pattern = this.arrayify(
      options.namespace
    )

    options.namespace = _.map(options.namespace, (n) => {
      if(n.indexOf('@') == -1) n = n+"-*"
      return n
    })

    pattern = _.unique(pattern.concat(['@nxus/*', '!@nxus/core']))

    if(options.appDir && fs.existsSync(options.appDir+"/package.json"))
      options.config = options.appDir+"/package.json"

    var config = options.config || findup('package.json')
    var scope = this.arrayify(
      options.scope
      || ['dependencies', 'devDependencies', 'peerDependencies']
    )
    if (typeof config === 'string') {
      config = require(path.resolve(config))
    }
    if(!config) return
    var names = scope.reduce((result, prop) => {
      return result.concat(Object.keys(config[prop] || {}))
    }, [])
    // find matched package names
    var matched = multimatch(names, pattern)
    matched.forEach((() => {
      return (name) => {
        var dir = (options.appDir || ".")+"/node_modules/"+name
        this.loadPackage(name, dir, packages)
      }
    })())
  }

  /**
   * Loads custom plugins in the <appDir>/modules directory
   * @param  {object} options  configuration options
   * @param  {packages} packages the array of packages currently loaded by Nxus
   */
  loadCustomPlugins(options, packages) {
    var customDir = options.appDir+'/modules'
    if (!fs.existsSync(customDir)) return

    var customPluginDirs = fs.readdirSync(customDir)
    
    customPluginDirs.forEach((name) => {
      var pkg = require(path.resolve(customDir + "/" + name))
      pkg._packageJson = this.getPluginPackageJson(customDir + "/" + name)
      pkg._pluginInfo = {}
      if(pkg._packageJson)
        pkg._pluginInfo.name = pkg._packageJson.name || null
      packages.push(pkg)
    })
  }

  /**
   * Loads manually passed in packages by path
   * @param  {object} options  configuration options
   * @param  {packages} packages the array of packages currently loaded by Nxus
   */
  loadPassedPlugins(options, packages) {
    var customPluginDirs = options.modules || []
    
    customPluginDirs.forEach((modulePath) => {
      var pkg = require(modulePath)
      pkg._packageJson = this.getPluginPackageJson(modulePath)
      pkg._pluginInfo = {}
      if(pkg._packageJson)
        pkg._pluginInfo.name = pkg._packageJson.name || null
      packages.push(pkg)
    })
  }
}

export default PluginManager